1. 进程合作: 多进程共同完成一个任务
	* 如果进程之间完全不知道对方的存在，则可能会产生怎样的错误？
	* 生活常识是怎么办到的？
2. 生产者与消费者问题
	* 一种思路, 先分析什么情况会停, 再分析什么会走?
		* 即sleep&&wakeup
	* 信号与信号量
		* 信号: 有 or 无
		* 信号量: 携带的信息更多
		* 0.11的kernal里没有信号量, 可以自己实现一个出来, 以系统调用的方式.
3. 信号量处理的是进程之间的协作问题, 但是对`信号量本身的修改带来的竞争条件`并没有解决。
	* 竞争是和调度有关, 即执行顺序
	* 解决办法
		* 加锁
		* `临界区`, 一次只允许一个进程进入的该进程的那一段代码
		* 进入临界区->临界区->退出临界区
	* 临界区的处理基本约束
		* 互斥
		* 有空让进
		* 有限等待
	* 方案一: 轮流操作, 不满足有空进入
	* 方案二: 标记法, 造成无限等待
	* 方法三: 非对称标记+轮转Peterson——两个进程
	* 方法四: 面包店算法——多个进程
	* 方法五: 借助硬件, 阻止中断, 单core
	* 方法六: 硬件,原子指令
4. 死锁的成因
	* 资源
		* 互斥使用
		* 不可抢占
	* 请求和保持
	* 循环等待
5. 死锁的解决
	* 死锁预防
		* 破坏死锁出现的条件. "no smoking"
		* 方法
			* 一次性申请所有资源
				* 预测未来, 编程困难
				* 很长时间才使用, 利用率低
			* 按顺序申请
				* 资源浪费, 每个进程的调度和对资源的使用时间不同
	* 死锁避免
		* 对资源进行检查, 如果会发生死锁, 就拒绝资源分配. "煤气超标"
		* 方法
			* 存在一个可完成的执行序列
			* 尝试分配+银行家算法
	* 死锁检测+恢复
		* 出现死锁, 让一些进程回滚, 让出资源
	* 死锁忽略
		* 